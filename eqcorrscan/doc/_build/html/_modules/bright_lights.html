

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bright_lights &mdash; EQcorrscan 0.1.2rc documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/EQcorrscan_logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="EQcorrscan 0.1.2rc documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> EQcorrscan
          

          
            
            <img src="../_static/EQcorrscan_logo.jpg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction to the EQcorrscan package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../updates.html">2. What&#8217;s new</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">3. EQcorrscan tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core.html">4. Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">5. Utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">EQcorrscan</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>bright_lights</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for bright_lights</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="sd">r&quot;&quot;&quot;Code to determine the brightness function of seismic data according to a \</span>
<span class="sd">three-dimensional travel-time grid.  This travel-time grid should be \</span>
<span class="sd">generated using the grid2time function of the NonLinLoc package by Anthony \</span>
<span class="sd">Lomax which can be found here: http://alomax.free.fr/nlloc/ and is not \</span>
<span class="sd">distributed within this package as this is a very useful stand-alone library \</span>
<span class="sd">for seismic event location.</span>

<span class="sd">This code is based on the method of Frank &amp; Shapiro 2014.\</span>

<span class="sd">:copyright:</span>
<span class="sd">    Calum Chamberlain, Chet Hopp.</span>

<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="_read_tt"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._read_tt">[docs]</a><span class="k">def</span> <span class="nf">_read_tt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">phaseout</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">ps_ratio</span><span class="o">=</span><span class="mf">1.68</span><span class="p">,</span>
             <span class="n">lags_switch</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to read in .csv files of slowness generated from Grid2Time \</span>
<span class="sd">    (part of NonLinLoc by Anthony Lomax) and convert this to a useful format \</span>
<span class="sd">    here.</span>

<span class="sd">    It should be noted that this can read either P or S travel-time grids, not</span>
<span class="sd">    both at the moment.</span>

<span class="sd">    :type path: str</span>
<span class="sd">    :param path: The path to the .csv Grid2Time outputs</span>
<span class="sd">    :type stations: list</span>
<span class="sd">    :param stations: List of station names to read slowness files for.</span>
<span class="sd">    :type phaseout: str</span>
<span class="sd">    :param phaseout: What phase to return the lagtimes in</span>
<span class="sd">    :type ps_ratio: float</span>
<span class="sd">    :param ps_ratio: p to s ratio for coversion</span>
<span class="sd">    :type lags_switch: bool</span>
<span class="sd">    :param lags_switch: Return lags or raw travel-times, if set to true will \</span>
<span class="sd">        return lags.</span>

<span class="sd">    :return: list stations, list of lists of tuples nodes, np.ndarray of \</span>
<span class="sd">        lags. station[1] refers to nodes[1] and lags[1] nodes[1][1] refers to \</span>
<span class="sd">        station[1] and lags[1][1] nodes[n][n] is a tuple of latitude, \</span>
<span class="sd">        longitude and depth.</span>

<span class="sd">    .. note:: This function currently needs comma seperated grid files in \</span>
<span class="sd">        NonLinLoc format.  Only certain versions of NonLinLoc write these csv \</span>
<span class="sd">        files, however it should be possible to read the binary files \</span>
<span class="sd">        directly.  If you find you need this capability let us know and we \</span>
<span class="sd">        can try and impliment it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">csv</span>
    <span class="kn">import</span> <span class="nn">glob</span>

    <span class="c1"># Locate the slowness file information</span>
    <span class="n">gridfiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stations_out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
        <span class="n">gridfiles</span> <span class="o">+=</span> <span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;*.&#39;</span> <span class="o">+</span> <span class="n">phase</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span>
                      <span class="s1">&#39;.time.csv&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;*.&#39;</span> <span class="o">+</span> <span class="n">phase</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="s1">&#39;*.csv&#39;</span><span class="p">):</span>
            <span class="n">stations_out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">station</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stations_out</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;No slowness files found&#39;</span><span class="p">)</span>
    <span class="c1"># Read the files</span>
    <span class="n">allnodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gridfile</span> <span class="ow">in</span> <span class="n">gridfiles</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;     Reading slowness from: &#39;</span> <span class="o">+</span> <span class="n">gridfile</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">gridfile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">traveltime</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">traveltime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">traveltime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">traveltime</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phase</span> <span class="o">==</span> <span class="n">phaseout</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">phase</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">traveltime</span> <span class="o">=</span> <span class="n">traveltime</span> <span class="o">/</span> <span class="n">ps_ratio</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traveltime</span> <span class="o">=</span> <span class="n">traveltime</span> <span class="o">*</span> <span class="n">ps_ratio</span>
        <span class="k">if</span> <span class="n">lags_switch</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">traveltime</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">traveltime</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">traveltime</span>
        <span class="k">if</span> <span class="s1">&#39;alllags&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="n">alllags</span> <span class="o">=</span> <span class="p">[</span><span class="n">lags</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alllags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">alllags</span><span class="p">,</span> <span class="p">[</span><span class="n">lags</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">allnodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="c1"># each element of allnodes should be the same as the</span>
        <span class="c1"># other one, e.g. for each station the grid must be the</span>
        <span class="c1"># same, hence allnodes=nodes</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">stations_out</span><span class="p">,</span> <span class="n">allnodes</span><span class="p">,</span> <span class="n">alllags</span></div>


<div class="viewcode-block" id="_resample_grid"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._resample_grid">[docs]</a><span class="k">def</span> <span class="nf">_resample_grid</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">mindepth</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span>
                   <span class="n">resolution</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to resample the lagtime grid to a given volume.  For use if \</span>
<span class="sd">    the grid from Grid2Time is too large or you want to run a faster, \</span>
<span class="sd">    downsampled scan.</span>

<span class="sd">    :type stations: list</span>
<span class="sd">    :param stations: List of station names from in the form where stations[i] \</span>
<span class="sd">        refers to nodes[i][:] and lags[i][:]</span>
<span class="sd">    :type nodes: list, tuple</span>
<span class="sd">    :param nodes: List of node points where nodes[i] referes to stations[i] \</span>
<span class="sd">        and nodes[:][:][0] is latitude in degrees, nodes[:][:][1] is \</span>
<span class="sd">        lonitude in degrees, nodes[:][:][2] is depth in km.</span>
<span class="sd">    :type lags: :class: &#39;numpy.array&#39;</span>
<span class="sd">    :param lags: Array of arrays where lags[i][:] refers to stations[i]. \</span>
<span class="sd">        lags[i][j] should be the delay to the nodes[i][j] for stations[i] in \</span>
<span class="sd">        seconds.</span>
<span class="sd">    :type mindepth: float</span>
<span class="sd">    :param mindepth: Upper limit of volume</span>
<span class="sd">    :type maxdepth: float</span>
<span class="sd">    :param maxdepth: Lower limit of volume</span>
<span class="sd">    :type corners: matplotlib.Path</span>
<span class="sd">    :param corners: matplotlib path of the corners for the 2D polygon to cut \</span>
<span class="sd">        to in lat and long</span>

<span class="sd">    :return: list stations, list of lists of tuples nodes, :class: \</span>
<span class="sd">        &#39;numpy.array&#39; lags station[1] refers to nodes[1] and lags[1] \</span>
<span class="sd">        nodes[1][1] refers to station[1] and lags[1][1] \</span>
<span class="sd">        nodes[n][n] is a tuple of latitude, longitude and depth.</span>

<span class="sd">    .. note:: This is an internal function and \</span>
<span class="sd">        should not be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    <span class="n">resamp_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">resamp_lags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Cut the volume</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="c1"># If the node is within the volume range, keep it</span>
        <span class="k">if</span> <span class="n">mindepth</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">maxdepth</span> <span class="ow">and</span>\
           <span class="n">corners</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">resamp_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">resamp_lags</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lags</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]])</span>
    <span class="c1"># Reshape the lags</span>
    <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">resamp_lags</span><span class="p">))</span>
    <span class="n">resamp_lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">resamp_lags</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resamp_lags</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Resample the nodes - they are sorted in order of size with largest long</span>
    <span class="c1"># then largest lat, then depth.</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;Grid now has &#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resamp_nodes</span><span class="p">)),</span> <span class="s1">&#39;nodes&#39;</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">stations</span><span class="p">,</span> <span class="n">resamp_nodes</span><span class="p">,</span> <span class="n">resamp_lags</span></div>


<div class="viewcode-block" id="_rm_similarlags"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._rm_similarlags">[docs]</a><span class="k">def</span> <span class="nf">_rm_similarlags</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to remove those nodes that have a very similar network \</span>
<span class="sd">    moveout to another lag.</span>

<span class="sd">    Will, for each node, calculate the difference in lagtime at each \</span>
<span class="sd">    station at every node, then sum these for each node to get a \</span>
<span class="sd">    cumulative difference in network moveout.  This will result in an \</span>
<span class="sd">    array of arrays with zeros on the diagonal.</span>

<span class="sd">    :type stations: list</span>
<span class="sd">    :param stations: List of station names from in the form where stations[i] \</span>
<span class="sd">        refers to nodes[i][:] and lags[i][:]</span>
<span class="sd">    :type nodes: list, tuple</span>
<span class="sd">    :param nodes: List of node points where nodes[i] referes to stations[i] \</span>
<span class="sd">        and nodes[:][:][0] is latitude in degrees, nodes[:][:][1] is \</span>
<span class="sd">        longitude in degrees, nodes[:][:][2] is depth in km.</span>
<span class="sd">    :type lags: :class: &#39;numpy.array&#39;</span>
<span class="sd">    :param lags: Array of arrays where lags[i][:] refers to stations[i]. \</span>
<span class="sd">        lags[i][j] should be the delay to the nodes[i][j] for stations[i] in \</span>
<span class="sd">        seconds</span>
<span class="sd">    :type threhsold: float</span>
<span class="sd">    :param threshold: Threshold for removal in seconds</span>

<span class="sd">    :returns: list stations, list of lists of tuples nodes, :class: \</span>
<span class="sd">        &#39;numpy.array&#39; lags station[1] refers to nodes[1] and lags[1] \</span>
<span class="sd">        nodes[1][1] refers to station[1] and lags[1][1] \</span>
<span class="sd">        nodes[n][n] is a tuple of latitude, longitude and depth.</span>

<span class="sd">    .. note:: This is an internal function and \</span>
<span class="sd">        should not be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>

    <span class="n">netdif</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">lags</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span>
                  <span class="n">lags</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="n">threshold</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
        <span class="n">_netdif</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">lags</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span>
                       <span class="n">lags</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>\
            <span class="o">&gt;</span> <span class="n">threshold</span>
        <span class="n">netdif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">netdif</span><span class="p">,</span> <span class="n">_netdif</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;% </span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="n">nodes_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">node_indeces</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">netdif</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">node_indeces</span><span class="p">]):</span>
            <span class="n">node_indeces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">nodes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">lags_out</span> <span class="o">=</span> <span class="n">lags</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">node_indeces</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Removed &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_out</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; duplicate nodes&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stations</span><span class="p">,</span> <span class="n">nodes_out</span><span class="p">,</span> <span class="n">lags_out</span></div>


<div class="viewcode-block" id="_rms"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._rms">[docs]</a><span class="k">def</span> <span class="nf">_rms</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate RMS of array</span>

<span class="sd">    .. note:: Just a lazy function using numpy functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">square</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span></div>


<div class="viewcode-block" id="_node_loop"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._node_loop">[docs]</a><span class="k">def</span> <span class="nf">_node_loop</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">clip_level</span><span class="p">,</span>
               <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mem_issue</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Internal function to allow for parallelisation of brightness.</span>

<span class="sd">    :type stations: list</span>
<span class="sd">    :param stations: List of stations to use.</span>
<span class="sd">    :type lags: np.ndarray</span>
<span class="sd">    :param lags: List of lags where lags[i[:]] are the lags for stations[i].</span>
<span class="sd">    :type stream: :class: `obspy.Stream`</span>
<span class="sd">    :param stream: Data stream to find the brightness for.</span>
<span class="sd">    :type clip_level: float</span>
<span class="sd">    :param clip_level: Upper limit for energy as a multiplier to the mean \</span>
<span class="sd">        energy.</span>
<span class="sd">    :type i: int</span>
<span class="sd">    :param i: Index of loop for parallelisation.</span>
<span class="sd">    :type mem_issue: bool</span>
<span class="sd">    :param mem_issue: If True will write to disk rather than storing data in \</span>
<span class="sd">        RAM.</span>
<span class="sd">    :type instance: int</span>
<span class="sd">    :param instance: instance for bulk parallelisation, only used if \</span>
<span class="sd">        mem_issue=true.</span>
<span class="sd">    :type plot: bool</span>
<span class="sd">    :param plot: Turn plotting on or off, defaults to False.</span>

<span class="sd">    :return: (i, energy (np.ndarray))</span>

<span class="sd">    .. note:: This is an internal function to ease parallel processing and \</span>
<span class="sd">        should not be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">obspy.Stream</span>
        <span class="kn">import</span> <span class="nn">obspy.Trace</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">))</span>
             <span class="k">if</span> <span class="n">stations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">]</span>
        <span class="c1"># Check that there is only one matching station</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Too many stations&#39;</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No station match&#39;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lag</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)))</span>
        <span class="n">lagged_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pad</span><span class="p">)))[</span><span class="nb">len</span><span class="p">(</span><span class="n">pad</span><span class="p">):]</span>
        <span class="c1"># Clip energy</span>
        <span class="n">lagged_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                <span class="n">clip_level</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="p">(</span><span class="n">lagged_energy</span> <span class="o">/</span>
                      <span class="n">_rms</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span>
            <span class="c1"># Cope with zeros enountered</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
            <span class="c1"># This is now an array of floats - we can convert this to int16</span>
            <span class="c1"># normalize to have max at max of int16 range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">scalor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="n">energy</span> <span class="o">*</span> <span class="n">scalor</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_energy</span> <span class="o">=</span> <span class="p">(</span><span class="n">lagged_energy</span> <span class="o">/</span>
                           <span class="n">_rms</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span>
            <span class="n">norm_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">norm_energy</span><span class="p">)</span>
            <span class="c1"># Convert to int16</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">(</span><span class="n">norm_energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">scalor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">norm_energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">norm_energy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="n">norm_energy</span> <span class="o">*</span> <span class="n">scalor</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_energy</span> <span class="o">=</span> <span class="n">norm_energy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="c1"># Apply lag to data and add it to energy - normalize the data here</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">energy</span><span class="p">,</span> <span class="n">norm_energy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lagged_energy</span> <span class="o">*</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="c1"># energy_tr=Trace(energy[l])</span>
            <span class="n">energy_tr</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">)</span>
            <span class="c1"># energy_tr=Trace(tr.data)</span>
            <span class="n">energy_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span>
            <span class="n">energy_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
            <span class="k">if</span> <span class="s1">&#39;energy_stream&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
                <span class="n">energy_stream</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">energy_tr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">energy_stream</span> <span class="o">+=</span> <span class="n">energy_tr</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lagged_energy</span><span class="p">))</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="c1"># Convert any nans to zeros</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">energy_tr</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">energy_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="s1">&#39;Stack&#39;</span>
        <span class="n">energy_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="n">energy_tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="s1">&#39;Energy&#39;</span>
        <span class="n">energy_stream</span> <span class="o">+=</span> <span class="n">energy_tr</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1"># energy_stream.plot(equal_scale=False, size=(800,600))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mem_issue</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">energy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">energy</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span></div>


<div class="viewcode-block" id="_cum_net_resp"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._cum_net_resp">[docs]</a><span class="k">def</span> <span class="nf">_cum_net_resp</span><span class="p">(</span><span class="n">node_lis</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to compute the cumulative network response by reading \</span>
<span class="sd">    saved energy .npy files.</span>

<span class="sd">    :type node_lis: np.ndarray</span>
<span class="sd">    :param node_lis: List of nodes (ints) to read from</span>
<span class="sd">    :type instance: int</span>
<span class="sd">    :param instance: Instance flag for parallelisation, defaults to 0.</span>

<span class="sd">    :returns: np.ndarray cum_net_resp, list of indeces used</span>

<span class="sd">    .. note:: This is an internal function to ease parallel processing and \</span>
<span class="sd">        should not be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span>
                           <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_lis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_lis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
    <span class="n">indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">))</span> <span class="o">*</span> <span class="n">node_lis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_lis</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">node_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span>
                              <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">updated_indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">node_energy</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">node_energy</span><span class="p">])</span>
        <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">temp</span><span class="p">[</span><span class="n">updated_indeces</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">updated_indeces</span><span class="p">))])</span>
        <span class="k">del</span> <span class="n">temp</span><span class="p">,</span> <span class="n">node_energy</span>
        <span class="n">updated_indeces</span><span class="p">[</span><span class="n">updated_indeces</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">indeces</span> <span class="o">=</span> <span class="n">updated_indeces</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;tmp&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/node_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">indeces</span></div>


<div class="viewcode-block" id="_find_detections"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights._find_detections">[docs]</a><span class="k">def</span> <span class="nf">_find_detections</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">thresh_type</span><span class="p">,</span>
                     <span class="n">samp_rate</span><span class="p">,</span> <span class="n">realstations</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to find detections within the cumulative network response \</span>
<span class="sd">    according to Frank et al. (2014).</span>

<span class="sd">    :type cum_net_resp: np.ndarray</span>
<span class="sd">    :param cum_net_resp: Array of cumulative network response for nodes</span>
<span class="sd">    :type nodes: list of tuples</span>
<span class="sd">    :param nodes: Nodes associated with the source of energy in the \</span>
<span class="sd">        cum_net_resp</span>
<span class="sd">    :type threshold: float</span>
<span class="sd">    :param threshold: Threshold value</span>
<span class="sd">    :type thresh_type: str</span>
<span class="sd">    :param thresh_type: Either MAD (Median Absolute Deviation) or abs \</span>
<span class="sd">        (absolute) or RMS (Root Mean Squared)</span>
<span class="sd">    :type samp_rate: float</span>
<span class="sd">    :param samp_rate: Sampling rate in Hz</span>
<span class="sd">    :type realstations: list of str</span>
<span class="sd">    :param realstations: List of stations used to make the cumulative network \</span>
<span class="sd">        response, will be reported in the DETECTION</span>
<span class="sd">    :type length: float</span>
<span class="sd">    :param length: Maximum length of peak to look for in seconds</span>

<span class="sd">    :return: detections as :class: DETECTION</span>

<span class="sd">    .. note:: This is an internal function to ease parallel processing and \</span>
<span class="sd">        should not be called directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter</span> <span class="kn">import</span> <span class="n">DETECTION</span>
    <span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="kn">import</span> <span class="n">findpeaks</span>

    <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)</span>  <span class="c1"># Force no NaNs</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nans present&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Mean of data is: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;RMS of data is: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)))))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;MAD of data is: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">))))</span>
    <span class="k">if</span> <span class="n">thresh_type</span> <span class="o">==</span> <span class="s1">&#39;MAD&#39;</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">))</span> <span class="o">*</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">thresh_type</span> <span class="o">==</span> <span class="s1">&#39;abs&#39;</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold</span>
    <span class="k">elif</span> <span class="n">thresh_type</span> <span class="o">==</span> <span class="s1">&#39;RMS&#39;</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">_rms</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)</span> <span class="o">*</span> <span class="n">threshold</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Threshold is set to: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">thresh</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Max of data is: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">)))</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">findpeaks</span><span class="o">.</span><span class="n">find_peaks2</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span>
                                  <span class="n">length</span> <span class="o">*</span> <span class="n">samp_rate</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxwidth</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">detections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DETECTION</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span>
                                        <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">samp_rate</span><span class="p">,</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="n">realstations</span><span class="p">),</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">thresh</span><span class="p">,</span>
                                        <span class="s1">&#39;brightness&#39;</span><span class="p">,</span> <span class="n">realstations</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">detections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;I have found &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; possible detections&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">detections</span></div>


<div class="viewcode-block" id="coherence"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights.coherence">[docs]</a><span class="k">def</span> <span class="nf">coherence</span><span class="p">(</span><span class="n">stream_in</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">],</span> <span class="n">clip</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to determine the average network coherence of a given \</span>
<span class="sd">    template or detection.  You will want your stream to contain only \</span>
<span class="sd">    signal as noise will reduce the coherence (assuming it is incoherant \</span>
<span class="sd">    random noise).</span>

<span class="sd">    :type stream: obspy.Stream</span>
<span class="sd">    :param stream: The stream of seismic data you want to calculate the \</span>
<span class="sd">            coherence for.</span>
<span class="sd">    :type stations: List of String</span>
<span class="sd">    :param stations: List of stations to use for coherence, default is all</span>
<span class="sd">    :type clip: tuple of Float</span>
<span class="sd">    :param clip: Default is to use all the data given - \</span>
<span class="sd">            tuple of start and end in seconds from start of trace</span>

<span class="sd">    :return: float - coherence, int number of channels used</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">match_filter</span> <span class="kn">import</span> <span class="n">normxcorr2</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">stream_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Copy the data before we remove stations</span>
    <span class="c1"># First check that all channels in stream have data of the same length</span>
    <span class="n">maxlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">maxlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;template without data&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>  <span class="c1"># Remove stations we don&#39;t want to use</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">maxlen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">+</span>
                          <span class="s1">&#39; is not the same length, padding </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                          <span class="s1">&#39;Length is &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; samples&#39;</span><span class="p">)</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxlen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pad</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxlen</span><span class="p">)</span>
    <span class="c1"># Clip the data to the set length</span>
    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">clip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">clip</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">coherence</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># Loop through channels and generate a correlation value for each</span>
    <span class="c1"># unique cross-channel pairing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)):</span>
            <span class="n">coherence</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normxcorr2</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                           <span class="n">stream</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coherence</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">coherence</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span></div>


<div class="viewcode-block" id="brightness"><a class="viewcode-back" href="../submodules/core.bright_lights.html#bright_lights.brightness">[docs]</a><span class="k">def</span> <span class="nf">brightness</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">thresh_type</span><span class="p">,</span>
               <span class="n">template_length</span><span class="p">,</span> <span class="n">template_saveloc</span><span class="p">,</span> <span class="n">coherence_thresh</span><span class="p">,</span>
               <span class="n">coherence_stations</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">],</span> <span class="n">coherence_clip</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">gap</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">clip_level</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pre_pick</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
               <span class="n">plotsave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Function to calculate the brightness function in terms of energy for \</span>
<span class="sd">    a day of data over the entire network for a given grid of nodes.</span>

<span class="sd">    Note data in stream must be all of the same length and have the same</span>
<span class="sd">    sampling rates.</span>

<span class="sd">    :type stations: list</span>
<span class="sd">    :param stations: List of station names from in the form where stations[i] \</span>
<span class="sd">        refers to nodes[i][:] and lags[i][:]</span>
<span class="sd">    :type nodes: list, tuple</span>
<span class="sd">    :param nodes: List of node points where nodes[i] referes to stations[i] \</span>
<span class="sd">        and nodes[:][:][0] is latitude in degrees, nodes[:][:][1] is \</span>
<span class="sd">        longitude in degrees, nodes[:][:][2] is depth in km.</span>
<span class="sd">    :type lags: :class: &#39;numpy.array&#39;</span>
<span class="sd">    :param lags: Array of arrays where lags[i][:] refers to stations[i]. \</span>
<span class="sd">        lags[i][j] should be the delay to the nodes[i][j] for stations[i] in \</span>
<span class="sd">        seconds.</span>
<span class="sd">    :type stream: :class: `obspy.Stream`</span>
<span class="sd">    :param data: Data through which to look for detections.</span>
<span class="sd">    :type threshold: float</span>
<span class="sd">    :param threshold: Threshold value for detection of template within the \</span>
<span class="sd">        brightness function</span>
<span class="sd">    :type thresh_type: str</span>
<span class="sd">    :param thresh_type: Either MAD or abs where MAD is the Median Absolute \</span>
<span class="sd">        Deviation and abs is an absoulte brightness.</span>
<span class="sd">    :type template_length: float</span>
<span class="sd">    :param template_length: Length of template to extract in seconds</span>
<span class="sd">    :type template_saveloc: str</span>
<span class="sd">    :param template_saveloc: Path of where to save the templates.</span>
<span class="sd">    :type coherence_thresh: tuple of floats</span>
<span class="sd">    :param coherence_thresh: Threshold for removing incoherant peaks in the \</span>
<span class="sd">            network response, those below this will not be used as templates. \</span>
<span class="sd">            Must be in the form of (a,b) where the coherence is given by: \</span>
<span class="sd">            a-kchan/b where kchan is the number of channels used to compute \</span>
<span class="sd">            the coherence</span>
<span class="sd">    :type coherence_stations: list</span>
<span class="sd">    :param coherence_stations: List of stations to use in the coherance \</span>
<span class="sd">            thresholding - defaults to &#39;all&#39; which uses all the stations.</span>
<span class="sd">    :type coherence_clip: float</span>
<span class="sd">    :param coherence_clip: tuple</span>
<span class="sd">    :type coherence_clip: Start and end in seconds of data to window around, \</span>
<span class="sd">            defaults to False, which uses all the data given.</span>
<span class="sd">    :type pre_pick: float</span>
<span class="sd">    :param pre_pick: Seconds before the detection time to include in template</span>
<span class="sd">    :type plotsave: bool</span>
<span class="sd">    :param plotsave: Save or show plots, if False will try and show the plots \</span>
<span class="sd">            on screen - as this is designed for bulk use this is set to \</span>
<span class="sd">            True to save any plots rather than show them if you create \</span>
<span class="sd">            them - changes the backend of matplotlib, so if is set to \</span>
<span class="sd">            False you will see NO PLOTS!</span>
<span class="sd">    :type cores: int</span>
<span class="sd">    :param core: Number of cores to use, defaults to 1.</span>
<span class="sd">    :type clip_level: float</span>
<span class="sd">    :param clip_level: Multiplier applied to the mean deviation of the energy \</span>
<span class="sd">                    as an upper limit, used to remove spikes (earthquakes, \</span>
<span class="sd">                    lightning, electircal spikes) from the energy stack.</span>
<span class="sd">    :type gap: float</span>
<span class="sd">    :param gap: Minimum inter-event time in seconds for detections</span>

<span class="sd">    :return: list of templates as :class: `obspy.Stream` objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">eqcorrscan.core.template_gen</span> <span class="kn">import</span> <span class="n">_template_gen</span>
    <span class="k">if</span> <span class="n">plotsave</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
    <span class="c1"># from joblib import Parallel, delayed</span>
    <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>
    <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
    <span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">read</span> <span class="k">as</span> <span class="n">obsread</span>
    <span class="kn">from</span> <span class="nn">obspy.core.event</span> <span class="kn">import</span> <span class="n">Catalog</span><span class="p">,</span> <span class="n">Event</span><span class="p">,</span> <span class="n">Pick</span><span class="p">,</span> <span class="n">WaveformStreamID</span><span class="p">,</span> <span class="n">Origin</span>
    <span class="kn">from</span> <span class="nn">obspy.core.event</span> <span class="kn">import</span> <span class="n">EventDescription</span><span class="p">,</span> <span class="n">CreationInfo</span><span class="p">,</span> <span class="n">Comment</span>
    <span class="kn">import</span> <span class="nn">obspy.Stream</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="kn">import</span> <span class="n">plotting</span>
    <span class="c1"># Check that we actually have the correct stations</span>
    <span class="n">realstations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">realstations</span> <span class="o">+=</span> <span class="n">station</span>
    <span class="k">del</span> <span class="n">st</span>
    <span class="n">stream_copy</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Force convert to int16</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream_copy</span><span class="p">:</span>
        <span class="c1"># int16 max range is +/- 32767</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">32767</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">32767</span> <span class="o">*</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
            <span class="c1"># Make sure that the data aren&#39;t clipped it they are high gain</span>
            <span class="c1"># scale the data</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c1"># The internal _node_loop converts energy to int16 too to converse memory,</span>
    <span class="c1"># to do this it forces the maximum of a single energy trace to be 500 and</span>
    <span class="c1"># normalises to this level - this only works for fewer than 65 channels of</span>
    <span class="c1"># data</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_copy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">130</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">OverflowError</span><span class="p">(</span><span class="s1">&#39;Too many streams, either re-code and cope with&#39;</span> <span class="o">+</span>
                            <span class="s1">&#39;either more memory usage, or less precision, or&#39;</span> <span class="o">+</span>
                            <span class="s1">&#39;reduce data volume&#39;</span><span class="p">)</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">detect_lags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">plotvar</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">mem_issue</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c1"># Loop through each node in the input</span>
    <span class="c1"># Linear run</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Computing the energy stacks&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mem_issue</span><span class="p">:</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">_node_loop</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">lags</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">stream</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
                    <span class="n">energy</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">energy</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;energy: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">energy</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">_node_loop</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">lags</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">stream</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                         <span class="n">mem_issue</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">energy</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Parallel run</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">cores</span>
        <span class="k">if</span> <span class="n">num_cores</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">num_cores</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_cores</span> <span class="o">&gt;</span> <span class="n">cpu_count</span><span class="p">():</span>
            <span class="n">num_cores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_node_loop</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="n">lags</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                                      <span class="n">stream</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">clip_level</span><span class="p">,</span>
                                                      <span class="n">mem_issue</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))]</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mem_issue</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Computing the cumulative network response from memory&#39;</span><span class="p">)</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">energy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">energy</span><span class="p">]</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">energy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="c1"># Now compute the cumulative network response and then detect possible</span>
    <span class="c1"># events</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mem_issue</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">energy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Indeces of maximum energy</span>
        <span class="k">print</span><span class="p">(</span><span class="n">indeces</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">indeces</span><span class="p">))</span>
        <span class="n">cum_net_resp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peak_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indeces</span><span class="p">)):</span>
            <span class="n">cum_net_resp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">peak_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">del</span> <span class="n">energy</span><span class="p">,</span> <span class="n">indeces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Reading the temp files and computing network response&#39;</span><span class="p">)</span>
        <span class="n">node_splits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_cores</span><span class="p">)</span>
        <span class="n">indeces</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">node_splits</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_cores</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">indeces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">node_splits</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_splits</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">indeces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">node_splits</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_cum_net_resp</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">indeces</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">instance</span><span class="p">))</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cores</span><span class="p">)]</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">responses</span><span class="p">))</span>
        <span class="n">node_indeces</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
        <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span>
        <span class="n">indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">indeces</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cum_net_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cum_net_resp</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indeces</span><span class="p">))])</span>
        <span class="n">peak_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_indeces</span><span class="p">[</span><span class="n">indeces</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">i</span><span class="p">]]</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indeces</span><span class="p">))]</span>
        <span class="k">del</span> <span class="n">indeces</span><span class="p">,</span> <span class="n">node_indeces</span>
    <span class="k">if</span> <span class="n">plotvar</span><span class="p">:</span>
        <span class="n">cum_net_trace</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cum_net_resp</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="o">=</span> <span class="s1">&#39;NR&#39;</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
        <span class="n">cum_net_trace</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">cum_net_trace</span><span class="p">)</span>
        <span class="n">cum_net_trace</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="s1">&#39;*N&#39;</span><span class="p">)</span>
        <span class="n">cum_net_trace</span> <span class="o">+=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="s1">&#39;*1&#39;</span><span class="p">)</span>
        <span class="n">cum_net_trace</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">])</span>
        <span class="c1"># np.save(&#39;cum_net_resp.npy&#39;,cum_net_resp)</span>
        <span class="c1">#     cum_net_trace.plot(size=(800,600), equal_scale=False,\</span>
        <span class="c1">#                        outfile=&#39;NR_timeseries.eps&#39;)</span>

    <span class="c1"># Find detection within this network response</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Finding detections in the cumulatve network response&#39;</span><span class="p">)</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">_find_detections</span><span class="p">(</span><span class="n">cum_net_resp</span><span class="p">,</span> <span class="n">peak_nodes</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                                  <span class="n">thresh_type</span><span class="p">,</span> <span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                                  <span class="n">realstations</span><span class="p">,</span> <span class="n">gap</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">cum_net_resp</span>
    <span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nodesout</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">good_detections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">detections</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Converting detections in to templates&#39;</span><span class="p">)</span>
        <span class="c1"># Generate a catalog of detections</span>
        <span class="n">detections_cat</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">detection</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">detections</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Converting for detection &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of &#39;</span> <span class="o">+</span>
                  <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">detections</span><span class="p">)))</span>
            <span class="c1"># Create an event for each detection</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
            <span class="c1"># Set up some header info for the event</span>
            <span class="n">event</span><span class="o">.</span><span class="n">event_descriptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EventDescription</span><span class="p">())</span>
            <span class="n">event</span><span class="o">.</span><span class="n">event_descriptions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Brightness detection&#39;</span>
            <span class="n">event</span><span class="o">.</span><span class="n">creation_info</span> <span class="o">=</span> <span class="n">CreationInfo</span><span class="p">(</span><span class="n">agency_id</span><span class="o">=</span><span class="s1">&#39;EQcorrscan&#39;</span><span class="p">)</span>
            <span class="n">copy_of_stream</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">stream_copy</span><span class="p">)</span>
            <span class="c1"># Convert detections to obspy.core.event type -</span>
            <span class="c1"># name of detection template is the node.</span>
            <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">detection</span><span class="o">.</span><span class="n">template_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">detection</span><span class="o">.</span><span class="n">template_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">detection</span><span class="o">.</span><span class="n">template_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1"># Look up node in nodes and find the associated lags</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">detect_lags</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">ksta</span> <span class="o">=</span> <span class="n">Comment</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;Number of stations=&#39;</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">detect_lags</span><span class="p">))</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Origin</span><span class="p">())</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ksta</span><span class="p">)</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">copy_of_stream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span>\
                <span class="n">detect_lags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">detection</span><span class="o">.</span><span class="n">detect_time</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">event</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">detect_lag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">detect_lags</span><span class="p">):</span>
                <span class="n">station</span> <span class="o">=</span> <span class="n">stations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">copy_of_stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                        <span class="n">_waveform_id</span> <span class="o">=</span> <span class="n">WaveformStreamID</span><span class="p">(</span><span class="n">station_code</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span>
                                                        <span class="n">station</span><span class="p">,</span>
                                                        <span class="n">channel_code</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span>
                                                        <span class="n">channel</span><span class="p">,</span>
                                                        <span class="n">network_code</span><span class="o">=</span><span class="s1">&#39;NA&#39;</span><span class="p">)</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">picks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pick</span><span class="p">(</span><span class="n">waveform_id</span><span class="o">=</span><span class="n">_waveform_id</span><span class="p">,</span>
                                                <span class="n">time</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span>
                                                <span class="n">detect_lag</span> <span class="o">+</span>
                                                <span class="n">detection</span><span class="o">.</span><span class="n">detect_time</span> <span class="o">+</span>
                                                <span class="n">pre_pick</span><span class="p">,</span>
                                                <span class="n">onset</span><span class="o">=</span><span class="s1">&#39;emergent&#39;</span><span class="p">,</span>
                                                <span class="n">evalutation_mode</span><span class="o">=</span><span class="s1">&#39;automatic&#39;</span><span class="p">))</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Generating template for detection: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="n">template</span> <span class="o">=</span> <span class="p">(</span><span class="n">_template_gen</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">picks</span><span class="p">,</span> <span class="n">copy_of_stream</span><span class="p">,</span>
                        <span class="n">template_length</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">))</span>
            <span class="n">template_name</span> <span class="o">=</span> <span class="n">template_saveloc</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span>\
                <span class="nb">str</span><span class="p">(</span><span class="n">template</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.ms&#39;</span>
            <span class="c1"># In the interests of RAM conservation we write then read</span>
            <span class="c1"># Check coherancy here!</span>
            <span class="n">temp_coher</span><span class="p">,</span> <span class="n">kchan</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">coherence_stations</span><span class="p">,</span>
                                          <span class="n">coherence_clip</span><span class="p">)</span>
            <span class="n">coh_thresh</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">coherence_thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">kchan</span> <span class="o">/</span> \
                <span class="nb">float</span><span class="p">(</span><span class="n">coherence_thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">temp_coher</span> <span class="o">&gt;</span> <span class="n">coh_thresh</span><span class="p">:</span>
                <span class="n">template</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;MSEED&quot;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Written template as: &#39;</span> <span class="o">+</span> <span class="n">template_name</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;---------------------------------coherence LEVEL: &#39;</span> <span class="o">+</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">temp_coher</span><span class="p">))</span>
                <span class="n">coherant</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Template was incoherant, coherence level: &#39;</span> <span class="o">+</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">temp_coher</span><span class="p">))</span>
                <span class="n">coherant</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">del</span> <span class="n">copy_of_stream</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">template</span>
            <span class="k">if</span> <span class="n">coherant</span><span class="p">:</span>
                <span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obsread</span><span class="p">(</span><span class="n">template_name</span><span class="p">))</span>
                <span class="n">nodesout</span> <span class="o">+=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="n">good_detections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">detection</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No template for you&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plotvar</span><span class="p">:</span>
        <span class="n">all_detections</span> <span class="o">=</span> <span class="p">[(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span>
                           <span class="n">detection</span><span class="o">.</span><span class="n">detect_time</span><span class="p">)</span><span class="o">.</span><span class="n">datetime</span>
                          <span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
        <span class="n">good_detections</span> <span class="o">=</span> <span class="p">[(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span>
                            <span class="n">detection</span><span class="o">.</span><span class="n">detect_time</span><span class="p">)</span><span class="o">.</span><span class="n">datetime</span>
                           <span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">good_detections</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plotsave</span><span class="p">:</span>
            <span class="n">plotting</span><span class="o">.</span><span class="n">NR_plot</span><span class="p">(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                             <span class="n">detections</span><span class="o">=</span><span class="n">good_detections</span><span class="p">,</span>
                             <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                             <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Network response&#39;</span><span class="p">)</span>
            <span class="c1"># cum_net_trace.plot(size=(800,600), equal_scale=False)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">savefile</span> <span class="o">=</span> <span class="s1">&#39;plots/&#39;</span> <span class="o">+</span>\
                <span class="n">cum_net_trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">+</span>\
                <span class="s1">&#39;_NR_timeseries.pdf&#39;</span>
            <span class="n">plotting</span><span class="o">.</span><span class="n">NR_plot</span><span class="p">(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="n">cum_net_trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                             <span class="n">detections</span><span class="o">=</span><span class="n">good_detections</span><span class="p">,</span>
                             <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">save</span><span class="o">=</span><span class="n">savefile</span><span class="p">,</span>
                             <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Network response&#39;</span><span class="p">)</span>
    <span class="n">nodesout</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodesout</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">templates</span><span class="p">,</span> <span class="n">nodesout</span></div>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, 2016: Calum John Chamberlain &amp; Chet Hopp.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.2rc',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>